/**
 * Facilitator Service
 *
 * Handles communication with CDP Facilitator for payment verification and settlement
 * Based on PRD Section 6.2
 */

import { generateJwt } from '@coinbase/cdp-sdk/auth';
import { PaymentPayload, PaymentRequirements, VerifyResponse, SettleResponse } from '../types';
import { CDP_SDK_VERSION, X402_SDK_VERSION } from '../constants';

const CDP_BASE_URL = 'https://api.cdp.coinbase.com';
const CDP_X402_PATH = '/platform/v2/x402';

export class FacilitatorService {
  private apiKeyId: string;
  private apiKeySecret: string;

  constructor() {
    this.apiKeyId = process.env.CDP_API_KEY_ID!;
    this.apiKeySecret = process.env.CDP_API_KEY_SECRET!;

    if (!this.apiKeyId || !this.apiKeySecret) {
      throw new Error('CDP_API_KEY_ID and CDP_API_KEY_SECRET must be set in environment variables');
    }
  }

  /**
   * Verify payment with CDP facilitator
   *
   * Validates payment signature and requirements without executing on-chain transaction
   *
   * @param paymentPayload - Payment payload from client's X-PAYMENT header
   * @param paymentRequirements - Payment requirements generated by server
   * @returns Verification result with payer address
   *
   * @example
   * const facilitator = new FacilitatorService();
   * const result = await facilitator.verify(paymentPayload, paymentRequirements);
   * if (result.isValid) {
   *   console.log('Payment verified for payer:', result.payer);
   * } else {
   *   console.error('Payment invalid:', result.invalidReason);
   * }
   */
  async verify(
    paymentPayload: PaymentPayload,
    paymentRequirements: PaymentRequirements
  ): Promise<VerifyResponse> {
    const endpoint = 'verify';
    const headers = await this.createAuthHeaders('POST', `${CDP_X402_PATH}/${endpoint}`);

    const response = await fetch(`${CDP_BASE_URL}${CDP_X402_PATH}/${endpoint}`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        x402Version: 1,
        paymentPayload: this.toJsonSafe(paymentPayload),
        paymentRequirements: this.toJsonSafe(paymentRequirements)
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Facilitator verify failed: ${response.status} ${errorText}`);
    }

    return response.json() as Promise<VerifyResponse>;
  }

  /**
   * Settle payment with CDP facilitator
   *
   * Executes payment on-chain via USDC.receiveWithAuthorization()
   *
   * @param paymentPayload - Payment payload from client's X-PAYMENT header
   * @param paymentRequirements - Payment requirements generated by server
   * @returns Settlement result with transaction hash
   *
   * @example
   * const facilitator = new FacilitatorService();
   * const result = await facilitator.settle(paymentPayload, paymentRequirements);
   * if (result.success) {
   *   console.log('Payment settled. Transaction:', result.transaction);
   * } else {
   *   console.error('Settlement failed:', result.errorReason);
   * }
   */
  async settle(
    paymentPayload: PaymentPayload,
    paymentRequirements: PaymentRequirements
  ): Promise<SettleResponse> {
    const endpoint = 'settle';
    const headers = await this.createAuthHeaders('POST', `${CDP_X402_PATH}/${endpoint}`);

    const response = await fetch(`${CDP_BASE_URL}${CDP_X402_PATH}/${endpoint}`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        x402Version: 1,
        paymentPayload: this.toJsonSafe(paymentPayload),
        paymentRequirements: this.toJsonSafe(paymentRequirements)
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Facilitator settle failed: ${response.status} ${errorText}`);
    }

    return response.json() as Promise<SettleResponse>;
  }

  /**
   * Generate CDP JWT for authentication
   *
   * @private
   * @param method - HTTP method (e.g., 'POST', 'GET')
   * @param path - API path (e.g., '/platform/v2/x402/verify')
   * @returns JWT token
   */
  private async generateJWT(method: string, path: string): Promise<string> {
    const requestHost = CDP_BASE_URL.replace('https://', '');

    return await generateJwt({
      apiKeyId: this.apiKeyId,
      apiKeySecret: this.apiKeySecret,
      requestMethod: method,
      requestHost,
      requestPath: path
    });
  }

  /**
   * Create auth headers for CDP API requests
   *
   * @private
   * @param method - HTTP method
   * @param path - API path
   * @returns Headers object with Authorization and Correlation-Context
   */
  private async createAuthHeaders(method: string, path: string): Promise<Record<string, string>> {
    const jwt = await this.generateJWT(method, path);

    return {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${jwt}`,
      'Correlation-Context': this.createCorrelationHeader()
    };
  }

  /**
   * Create correlation context header
   *
   * @private
   * @returns Correlation context string
   */
  private createCorrelationHeader(): string {
    const data = {
      sdk_version: CDP_SDK_VERSION,
      sdk_language: 'typescript',
      source: 'x402',
      source_version: X402_SDK_VERSION
    };

    return Object.entries(data)
      .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
      .join(',');
  }

  /**
   * Convert to JSON-safe format (handles BigInt, etc.)
   *
   * @private
   * @param obj - Object to convert
   * @returns JSON-safe object
   */
  private toJsonSafe(obj: unknown): unknown {
    return JSON.parse(JSON.stringify(obj, (_, value) =>
      typeof value === 'bigint' ? value.toString() : value
    ));
  }
}
